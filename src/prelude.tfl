; The Trifle prelude. These are functions and macros that are included
; in every namespace. Functions are written without error checking, as
; tracebacks should be clear enough. Macros are written more
; defensively.

; todo: we should document whether functions are built-in or in the
; prelude.
; todo: the docs should have links to the source code where the
; function/macro was defined.
; todo: docstrings

; TODO: We need to measure branch coverage of prelude code, to ensure
; everything is tested.

; todo: macros should check argument types to aid debugging
(macro set! (symbol value)
  "Set SYMBOL to VALUE in the current scope."
  (quote
    (set-symbol! (quote (unquote symbol)) (unquote value))
  )
)

; todo: macros should check argument types to aid debugging
; todo: unit test
(macro function (name params :rest body)
  "Define a function called NAME with parameters PARAMS
and body BODY."
  (quote
    (set! (unquote name)
      (lambda (unquote params) (unquote* body))
    )
  )
)

(function list (:rest items)
  "Create a new list of ITEMS."
  items
)

(function inc (x)
  "Add one to X."
  (+ x 1)
)

(macro inc! (x)
  (quote (set! (unquote x) (inc (unquote x))))
)

(function dec (x)
  "Subtract one from X."
  (- x 1)
)

(macro dec! (x)
  (quote (set! (unquote x) (dec (unquote x))))
)

(macro for-each (name some-list :rest body)
  (let (index-var (fresh-symbol))
    (quote
      (let ((unquote index-var) 0)
        (while (< (unquote index-var) (length (unquote some-list)))
          (let ((unquote name) (get-index (unquote some-list) (unquote index-var)))
            (unquote* body)
          )
          (inc! (unquote index-var))
        )
      )
    )
  )
)

(function push! (sequence value)
  "Insert VALUE at the start of SEQUENCE."
  (insert! sequence 0 value)
)

(function append! (sequence value)
  "Insert VALUE at the end of SEQUENCE."
  (insert! sequence (length sequence) value)
)

(function map (func sequence)
  (let (result (empty sequence))
    (for-each item sequence
      (append! result (func item))
    )
    result
  )
)

;TODO: unit test, docs, helpful error on non-sequence
(function empty (sequence)
  "Return an empty sequence of the same type as SEQUENCE."
  (case
    ((list? sequence) (list))
    ((string? sequence) "")
    ((bytestring? sequence) #bytes(""))
  )
)

;TODO: write a when macro, and use it here.
(function filter (func sequence)
  "Return a fresh sequence containing the elements 
for which (FUNC element) is truthy."
  (let (result (empty sequence))
    (for-each item sequence
      (if (func item)
        (append! result item)
      )
    )
    result
  )
)

;TODO: unit test
;TODOC
(function join! (seq1 seq2)
  "Modify SEQ1 by appending all the elements of SEQ2."
  (for-each element seq2
    (append! seq1 element)
  )
)

(function first (seq)
  (get-index seq 0)
)
(function second (seq)
  (get-index seq 1)
)
(function third (seq)
  (get-index seq 2)
)
(function fourth (seq)
  (get-index seq 3)
)
(function fifth (seq)
  (get-index seq 4)
)

(function last (seq)
  (get-index seq -1)
)

(function zero? (x)
  (equal? x 0)
)

(macro unless (condition :rest body)
  (quote
    (if (not (unquote condition))
      (do (unquote* body))
    )
  )
)

; TODO: write in terms of a slice function.
; TODO: be stricter and throw an index error on an empty list.
(function rest (seq)
  (let (i 0
        ; We can't use case here, since it calls rest.
        result (if (list? seq)
                 (list)
                 (if (string? seq)
                   ""
                   #bytes(""))
               )
       )
    (for-each item seq
      (unless (equal? i 0)
        (append! result item)
      )
      (inc! i)
    )
    result
  )
)

; TODO: throw an error on max < 0.
(function range (max)
  "Return a list of integers from 0 to max - 1."
  (let (result (list)
        i 0
       )
    (while (< i max)
      (append! result i)
      (inc! i)
    )
    result
  )
)

; TODO: case should throw an error on invalid input
; e.g. (case ())
(macro case (:rest clauses)
  (if clauses
    (let (clause (first clauses))
      (quote
        (if (unquote (first clause))
          (do (unquote* (rest clause)))
          (case (unquote* (rest clauses)))
        )
      )
    )
  )
)

(function do (:rest args)
  (if args
    (last args)
  )
)

(function truthy? (value)
  (if value #true #false)
)

(function not (value)
  (if value #false #true)
)

(macro and (:rest values)
  (if values
    (let (symbol (fresh-symbol))
      (quote
        (let ((unquote symbol) (unquote (first values)))
          (if (unquote symbol)
            (and (unquote* (rest values)))
            (unquote symbol)
          )
        )
      )
    )
    #true
  )
)

(macro or (:rest values)
  (if values
    (let (symbol (fresh-symbol))
      (quote
        (let ((unquote symbol) (unquote (first values)))
          (if (unquote symbol)
            (unquote symbol)
            (or (unquote* (rest values)))
          )
        )
      )
    )
    #false
  )
)

; TODO: < is variadic, but these all only take two arguments.
(function > (x y)
  "Return #true if X is greater than Y."
  (and (not (< x y)) (not (equal? x y)))
)
(function >= (x y)
  "Return #true if X is greater than or equal to Y."
  (or (> x y) (equal? x y))
)
(function <= (x y)
  "Return #true if X is less than or equal to Y."
  (or (< x y) (equal? x y))
)

; TODO: > should handle strings, characters etc too.
; TODO: fix stack overflow.
; TODO: allow specifying a custom comparison function
(function sort! (sequence)
  "Modify SEQUENCE so it is sorted in ascending order."

  ; TODO: Inline functions like this work, but their names could leak
  ; if any of these functions names are used as globals.  A macro for
  ; this use case would be nice.
  (function swap! (i j)
    "Swap the element at index I with the element at index J."
    (let (temp (get-index sequence i))
      (set-index! sequence i (get-index sequence j))
      (set-index! sequence j temp)
    )
  )

  (function partition-from-to! (low high)
    "Partition the sequence by a pivot between LOW and HIGH (inclusive)."
    (unless (equal? low high)
      (let (
          pivot-index (div (+ low high) 2)
          pivot (get-index sequence pivot-index)
        )
        (swap! pivot-index high)
      )
    )
  )
  
  (sort-from-to! 0 (length sequence))
)
