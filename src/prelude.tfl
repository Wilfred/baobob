; The Trifle prelude. These are functions and macros that are included
; in every namespace. Functions are written without error checking, as
; tracebacks should be clear enough. Macros are written more
; defensively.

; todo: we should document whether functions are built-in or in the
; prelude.
; todo: the docs should have links to the source code where the
; function/macro was defined.
; todo: docstrings

; TODO: We need to measure branch coverage of prelude code, to ensure
; everything is tested.

; todo: macros should check argument types to aid debugging
(macro set! (symbol value)
  (quote
    (set-symbol! (quote (unquote symbol)) (unquote value))
  )
)

; todo: macros should check argument types to aid debugging
; todo: unit test
(macro function (name params :rest body)
  (quote
    (set! (unquote name)
      (lambda (unquote params) (unquote* body))
    )
  )
)

(function list (:rest items) items)

(function inc (x) (+ x 1))

(macro inc! (x)
  (quote (set! (unquote x) (inc (unquote x))))
)

(function dec (x) (- x 1))

(macro dec! (x)
  (quote (set! (unquote x) (dec (unquote x))))
)

(macro for-each (name some-list :rest body)
  (let (index-var (fresh-symbol))
    (quote
      (let ((unquote index-var) 0)
        (while (< (unquote index-var) (length (unquote some-list)))
          (let ((unquote name) (get-index (unquote some-list) (unquote index-var)))
            (unquote* body)
          )
          (inc! (unquote index-var))
        )
      )
    )
  )
)

(function map (func sequence)
  (let
    (result
      (case
        ((list? sequence) (list))
        ((string? sequence) "")
        (:else #bytes(""))
      )
    )
    (for-each item sequence
      (append! result (func item))
    )
    result
  )
)

(function first (seq)
  (get-index seq 0)
)
(function second (seq)
  (get-index seq 1)
)
(function third (seq)
  (get-index seq 2)
)
(function fourth (seq)
  (get-index seq 3)
)
(function fifth (seq)
  (get-index seq 4)
)

(function last (seq)
  (get-index seq -1)
)

(function zero? (x)
  (equal? x 0)
)

(macro unless (condition :rest body)
  (quote
    (if (not (unquote condition))
      (do (unquote* body))
    )
  )
)

; TODO: write in terms of a slice function.
; TODO: be stricter and throw an index error on an empty list.
(function rest (seq)
  (let (i 0
        ; We can't use case here, since it calls rest.
        result (if (list? seq)
                 (list)
                 (if (string? seq)
                   ""
                   #bytes(""))
               )
       )
    (for-each item seq
      (unless (equal? i 0)
        (append! result item)
      )
      (inc! i)
    )
    result
  )
)

; TODO: throw an error on max < 0.
(function range (max)
  "Return a list of integers from 0 to max - 1."
  (let (result (list)
        i 0
       )
    (while (< i max)
      (append! result i)
      (inc! i)
    )
    result
  )
)

; TODO: case should throw an error on invalid input
; e.g. (case ())
(macro case (:rest clauses)
  (if clauses
    (let (clause (first clauses))
      (quote
        (if (unquote (first clause))
          (do (unquote* (rest clause)))
          (case (unquote* (rest clauses)))
        )
      )
    )
  )
)

(function do (:rest args)
  (if args
    (last args)
  )
)

(function truthy? (value)
  (if value #true #false)
)

(function not (value)
  (if value #false #true)
)

(macro and (:rest values)
  (if values
    (let (symbol (fresh-symbol))
      (quote
        (let ((unquote symbol) (unquote (first values)))
          (if (unquote symbol)
            (and (unquote* (rest values)))
            (unquote symbol)
          )
        )
      )
    )
    #true
  )
)

; TODOC
; TODO: unit test
; TODO: error on incomparable types
(function > (x y)
  (and (not (equal? x y)) (not (< x y)))
)
