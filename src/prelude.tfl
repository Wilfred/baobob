; The Trifle prelude. These are functions and macros that are included
; in every namespace. Functions are written without error checking, as
; tracebacks should be clear enough. Macros are written more
; defensively.

; todo: we should document whether functions are built-in or in the
; prelude.
; todo: the docs should have links to the source code where the
; function/macro was defined.
; todo: docstrings

; TODO: We need to measure branch coverage of prelude code, to ensure
; everything is tested.

; todo: macros should check argument types to aid debugging
(macro set! (symbol value)
  "Set SYMBOL to VALUE in the current scope."
  (quote
    (set-symbol! (quote (unquote symbol)) (unquote value))
  )
)

; todo: macros should check argument types to aid debugging
; todo: unit test
(macro function (name params :rest body)
  "Define a function called NAME with parameters PARAMS
and body BODY."
  (quote
    (set! (unquote name)
      (lambda (unquote params) (unquote* body))
    )
  )
)

(function identity (value)
  "Return VALUE unchanged."
  value
)

(function list (:rest items)
  "Create a new list of ITEMS."
  items
)

(function inc (x)
  "Add one to X."
  (+ x 1)
)

(macro inc! (x)
  (quote (set! (unquote x) (inc (unquote x))))
)

(function dec (x)
  "Subtract one from X."
  (- x 1)
)

(macro dec! (x)
  (quote (set! (unquote x) (dec (unquote x))))
)

(macro for-each (name some-list :rest body)
  (let (index-var (fresh-symbol))
    (quote
      (let ((unquote index-var) 0)
        (while (< (unquote index-var) (length (unquote some-list)))
          (let ((unquote name) (get-index (unquote some-list) (unquote index-var)))
            (unquote* body)
          )
          (inc! (unquote index-var))
        )
      )
    )
  )
)

; TODO: error on non-sequence
(function empty? (sequence)
  "Return #true if SEQUENCE contains no elements."
  (zero? (length sequence))
)

(function push! (sequence value)
  "Insert VALUE at the start of SEQUENCE."
  (insert! sequence 0 value)
)

(function append! (sequence value)
  "Insert VALUE at the end of SEQUENCE."
  (insert! sequence (length sequence) value)
)

(function map (func sequence)
  (let (result (empty sequence))
    (for-each item sequence
      (append! result (func item))
    )
    result
  )
)

;TODO: helpful error on non-sequence
(function copy (sequence)
  "Return a fresh copy of SEQUENCE.
This is a shallow copy operation, so the copy shares the values."
  (map identity sequence)
)

;TODO: helpful error on non-sequence
(function empty (sequence)
  "Return an empty sequence of the same type as SEQUENCE."
  (case
    ((list? sequence) (list))
    ((string? sequence) "")
    ((bytestring? sequence) #bytes(""))
  )
)

;TODO: write a when macro, and use it here.
(function filter (func sequence)
  "Return a fresh sequence containing the elements 
for which (FUNC element) is #true."
  (let (result (empty sequence))
    (for-each item sequence
      (if (func item)
        (append! result item)
      )
    )
    result
  )
)

(function join! (sequence :rest sequences)
  "Modify SEQUENCE by appending all the elements from each of SEQUENCES."
  (for-each additional-sequence sequences
    (for-each element additional-sequence
      (append! sequence element)
    )
  )
)

;TODO: unit test
;TODOC
(function join (sequence :rest sequences)
  "Return a copy of SEQUENCE with all the elements from SEQUENCES appended."
  (let (result (copy sequence))
    (for-each additional-sequence sequences
      (for-each element additional-sequence
        (append! result element)
      )
    )
    result
  )
)

(function first (seq)
  (get-index seq 0)
)
(function second (seq)
  (get-index seq 1)
)
(function third (seq)
  (get-index seq 2)
)
(function fourth (seq)
  (get-index seq 3)
)
(function fifth (seq)
  (get-index seq 4)
)

(function last (seq)
  (get-index seq -1)
)

(function zero? (x)
  (equal? x 0)
)

(macro unless (condition :rest body)
  (quote
    (if (not (unquote condition))
      (do (unquote* body))
    )
  )
)

; TODO: write in terms of a slice function.
; TODO: be stricter and throw an index error on an empty list.
(function rest (seq)
  (let (i 0
        ; We can't use case here, since it calls rest.
        result (if (list? seq)
                 (list)
                 (if (string? seq)
                   ""
                   #bytes(""))
               )
       )
    (for-each item seq
      (unless (equal? i 0)
        (append! result item)
      )
      (inc! i)
    )
    result
  )
)

; TODO: throw an error on max < 0.
(function range (max)
  "Return a list of integers from 0 to max - 1."
  (let (result (list)
        i 0
       )
    (while (< i max)
      (append! result i)
      (inc! i)
    )
    result
  )
)

; TODO: case should throw an error on invalid input
; e.g. (case ())
(macro case (:rest clauses)
  (if (not (empty? clauses))
    (let (clause (first clauses))
      (quote
        (if (unquote (first clause))
          (do (unquote* (rest clause)))
          (case (unquote* (rest clauses)))
        )
      )
    )
  )
)

(function do (:rest args)
  (if (not (empty? args))
    (last args)
  )
)

(function not (value)
  (if value #false #true)
)

(macro and (:rest values)
  (if (not (empty? values))
    (let (symbol (fresh-symbol))
      (quote
        (let ((unquote symbol) (unquote (first values)))
          (if (unquote symbol)
            (and (unquote* (rest values)))
            (unquote symbol)
          )
        )
      )
    )
    #true
  )
)

(macro or (:rest values)
  (if (not (empty? values))
    (let (symbol (fresh-symbol))
      (quote
        (let ((unquote symbol) (unquote (first values)))
          (if (unquote symbol)
            (unquote symbol)
            (or (unquote* (rest values)))
          )
        )
      )
    )
    #false
  )
)

; TODO: < is variadic, but these all only take two arguments.
(function > (x y)
  "Return #true if X is greater than Y."
  (and (not (< x y)) (not (equal? x y)))
)
(function >= (x y)
  "Return #true if X is greater than or equal to Y."
  (or (> x y) (equal? x y))
)
(function <= (x y)
  "Return #true if X is less than or equal to Y."
  (or (< x y) (equal? x y))
)

; TODO: > should handle strings, characters etc, not just numbers.
; TODO: fix stack overflow.
; TODO: allow specifying a custom comparison function
; TODO: add mutating version
(function sort (sequence)
  "Return a sorted copy of SEQUENCE."
  (if (< (length sequence) 2)
    sequence
    (let (pivot (first sequence)
          unsorted (rest sequence)
          lesser (filter (lambda (x) (< x pivot)) unsorted)
          greater (filter (lambda (x) (>= x pivot)) unsorted)
         )
      (join (sort lesser) (list pivot) (sort greater))
    )
  )
)
